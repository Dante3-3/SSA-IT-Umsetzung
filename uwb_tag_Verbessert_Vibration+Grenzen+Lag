#include <SPI.h>
#include <DW1000Ranging.h>
#include <WiFi.h>
#include <esp_now.h>

#define SPI_SCK 18
#define SPI_MISO 19
#define SPI_MOSI 23
#define DW_CS 4
#define PIN_RST 27
#define PIN_IRQ 2  // Ändere auf GPIO 2

double FIELD_WIDTH = 3.0;
#define FIELD_HEIGHT FIELD_WIDTH
#define DISTANCE_A1_A2 3.0
#define VIBRO1 12

typedef struct struct_message {
  int b;
} struct_message;

struct_message myData;
SPIClass hspi(HSPI); // HSPI für DW1000

void OnDataRecv(const esp_now_recv_info_t *recv_info, const uint8_t *incomingData, int len) {
    memcpy(&myData, incomingData, sizeof(myData));

    Serial.print("Data received: ");
    Serial.println(len);
    Serial.print("Integer Value: ");
    Serial.println(myData.b);

    if (myData.b == 1) {
        FIELD_WIDTH += 1.0;
        Serial.print("FIELD_WIDTH erhöht: ");
        Serial.println(FIELD_WIDTH);
    }
}

void setup() {
    Serial.begin(115200);
    pinMode(VIBRO1, OUTPUT);

    hspi.begin(SPI_SCK, SPI_MISO, SPI_MOSI, DW_CS);
    DW1000Ranging.initCommunication(PIN_RST, DW_CS, PIN_IRQ);
    DW1000Ranging.attachNewRange(newRange);
    DW1000Ranging.attachNewDevice(newDevice);
    DW1000Ranging.attachInactiveDevice(inactiveDevice);
    DW1000Ranging.startAsTag("7D:00:22:EA:82:60:3B:9C", DW1000.MODE_LONGDATA_RANGE_LOWPOWER);

    WiFi.mode(WIFI_STA);
    WiFi.setSleep(false);
    WiFi.setChannel(1);

    if (esp_now_init() != ESP_OK) {
        Serial.println("Error initializing ESP-NOW");
        return;
    }

    esp_now_register_recv_cb(OnDataRecv);
}

void loop() {
    DW1000Ranging.loop();
}

void newRange() {
    hspi.beginTransaction(SPISettings(16000000, MSBFIRST, SPI_MODE0));
    double a2_range = DW1000Ranging.getDistantDevice()->getRange();
    hspi.endTransaction();

    double a1_range = DISTANCE_A1_A2;
    double tag_x = 0, tag_y = 0;

    if (a2_range > 0 && a1_range > 0) {
        calculateTagPosition(a2_range, a1_range, DISTANCE_A1_A2, &tag_x, &tag_y);

        Serial.print("Tag Position: x = ");
        Serial.print(tag_x);
        Serial.print(", y = ");
        Serial.println(tag_y);

        if (is_out_of_bounds(tag_x, tag_y)) {
            Serial.println("Tag ist außerhalb des Spielfelds.");
            vibrieren(VIBRO1, true);
        } else {
            Serial.println("Tag ist innerhalb des Spielfelds.");
            vibrieren(VIBRO1, false);
        }
    } else {
        Serial.println("Ungültige Entfernungsdaten.");
    }
}

void calculateTagPosition(double a, double b, double c, double *x, double *y) {
    double cos_a = (b * b + c * c - a * a) / (2 * b * c);
    cos_a = fmax(-1.0, fmin(1.0, cos_a));
    *x = b * cos_a;
    *y = sqrt(fmax(0.0, b * b - (*x) * (*x)));
}

bool is_out_of_bounds(double tag_x, double tag_y) {
    return tag_x < 0 || tag_x > FIELD_WIDTH || tag_y < 0 || tag_y > FIELD_HEIGHT;
}

void vibrieren(byte pin, boolean aktiv) {
    if (aktiv) {
        for (int i = 0; i < 10; i++) {
            digitalWrite(pin, HIGH);
            delay(30);
            digitalWrite(pin, LOW);
            delay(20);
        }
    } else {
        digitalWrite(pin, LOW);
    }
}

void newDevice(DW1000Device *device) {
    Serial.print("New device added! Short address: ");
    Serial.println(device->getShortAddress(), HEX);
}

void inactiveDevice(DW1000Device *device) {
    Serial.print("Inactive device removed: ");
    Serial.println(device->getShortAddress(), HEX);
}
